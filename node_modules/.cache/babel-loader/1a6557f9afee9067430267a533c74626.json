{"ast":null,"code":"import { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\nexport default function nodeStreamIterator(stream) {\n  var cleanup = null;\n  var error = null;\n  var done = false;\n  var data = [];\n  var waiting = [];\n  function onData(chunk) {\n    if (error) return;\n    if (waiting.length) {\n      var shiftedArr = waiting.shift();\n      if (Array.isArray(shiftedArr) && shiftedArr[0]) {\n        return shiftedArr[0]({\n          value: chunk,\n          done: false\n        });\n      }\n    }\n    data.push(chunk);\n  }\n  function onError(err) {\n    error = err;\n    var all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[1](err);\n    });\n    !cleanup || cleanup();\n  }\n  function onEnd() {\n    done = true;\n    var all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[0]({\n        value: undefined,\n        done: true\n      });\n    });\n    !cleanup || cleanup();\n  }\n  cleanup = function () {\n    cleanup = null;\n    stream.removeListener(\"data\", onData);\n    stream.removeListener(\"error\", onError);\n    stream.removeListener(\"end\", onEnd);\n    stream.removeListener(\"finish\", onEnd);\n    stream.removeListener(\"close\", onEnd);\n  };\n  stream.on(\"data\", onData);\n  stream.on(\"error\", onError);\n  stream.on(\"end\", onEnd);\n  stream.on(\"finish\", onEnd);\n  stream.on(\"close\", onEnd);\n  function getNext() {\n    return new Promise(function (resolve, reject) {\n      if (error) return reject(error);\n      if (data.length) return resolve({\n        value: data.shift(),\n        done: false\n      });\n      if (done) return resolve({\n        value: undefined,\n        done: true\n      });\n      waiting.push([resolve, reject]);\n    });\n  }\n  var iterator = {\n    next: function () {\n      return getNext();\n    }\n  };\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function () {\n      return this;\n    };\n  }\n  return iterator;\n}","map":{"version":3,"sources":["../../../../src/link/http/iterators/nodeStream.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/nodeStream.ts\n */\n\nimport { Readable as NodeReadableStream } from \"stream\";\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities\";\n\ninterface NodeStreamIterator<T> {\n  next(): Promise<IteratorResult<T, boolean | undefined>>;\n  [Symbol.asyncIterator]?(): AsyncIterator<T>;\n}\n\nexport default function nodeStreamIterator<T>(\n  stream: NodeReadableStream\n): AsyncIterableIterator<T> {\n  let cleanup: (() => void) | null = null;\n  let error: Error | null = null;\n  let done = false;\n  const data: unknown[] = [];\n\n  const waiting: [\n    (\n      value:\n        | IteratorResult<T, boolean | undefined>\n        | PromiseLike<IteratorResult<T, boolean | undefined>>\n    ) => void,\n    (reason?: any) => void\n  ][] = [];\n\n  function onData(chunk: any) {\n    if (error) return;\n    if (waiting.length) {\n      const shiftedArr = waiting.shift();\n      if (Array.isArray(shiftedArr) && shiftedArr[0]) {\n        return shiftedArr[0]({ value: chunk, done: false });\n      }\n    }\n    data.push(chunk);\n  }\n  function onError(err: Error) {\n    error = err;\n    const all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[1](err);\n    });\n    !cleanup || cleanup();\n  }\n  function onEnd() {\n    done = true;\n    const all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[0]({ value: undefined, done: true });\n    });\n    !cleanup || cleanup();\n  }\n\n  cleanup = function () {\n    cleanup = null;\n    stream.removeListener(\"data\", onData);\n    stream.removeListener(\"error\", onError);\n    stream.removeListener(\"end\", onEnd);\n    stream.removeListener(\"finish\", onEnd);\n    stream.removeListener(\"close\", onEnd);\n  };\n  stream.on(\"data\", onData);\n  stream.on(\"error\", onError);\n  stream.on(\"end\", onEnd);\n  stream.on(\"finish\", onEnd);\n  stream.on(\"close\", onEnd);\n\n  function getNext(): Promise<IteratorResult<T, boolean | undefined>> {\n    return new Promise(function (resolve, reject) {\n      if (error) return reject(error);\n      if (data.length) return resolve({ value: data.shift() as T, done: false });\n      if (done) return resolve({ value: undefined, done: true });\n      waiting.push([resolve, reject]);\n    });\n  }\n\n  const iterator: NodeStreamIterator<T> = {\n    next(): Promise<IteratorResult<T, boolean | undefined>> {\n      return getNext();\n    },\n  };\n\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<T> {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<T>;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}