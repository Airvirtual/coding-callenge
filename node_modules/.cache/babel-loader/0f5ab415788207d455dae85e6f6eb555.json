{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { parse } from 'graphql';\nvar docCache = new Map();\nvar fragmentSourceMap = new Map();\nvar printFragmentWarnings = true;\nvar experimentalFragmentVariables = false;\nfunction normalize(string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\nfunction cacheKeyFromLoc(loc) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\nfunction processFragments(ast) {\n  var seenKeys = new Set();\n  var definitions = [];\n  ast.definitions.forEach(function (fragmentDefinition) {\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n      var sourceKeySet = fragmentSourceMap.get(fragmentName);\n      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\" + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\" + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n      } else if (!sourceKeySet) {\n        fragmentSourceMap.set(fragmentName, sourceKeySet = new Set());\n      }\n      sourceKeySet.add(sourceKey);\n      if (!seenKeys.has(sourceKey)) {\n        seenKeys.add(sourceKey);\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  });\n  return __assign(__assign({}, ast), {\n    definitions: definitions\n  });\n}\nfunction stripLoc(doc) {\n  var workSet = new Set(doc.definitions);\n  workSet.forEach(function (node) {\n    if (node.loc) delete node.loc;\n    Object.keys(node).forEach(function (key) {\n      var value = node[key];\n      if (value && typeof value === 'object') {\n        workSet.add(value);\n      }\n    });\n  });\n  var loc = doc.loc;\n  if (loc) {\n    delete loc.startToken;\n    delete loc.endToken;\n  }\n  return doc;\n}\nfunction parseDocument(source) {\n  var cacheKey = normalize(source);\n  if (!docCache.has(cacheKey)) {\n    var parsed = parse(source, {\n      experimentalFragmentVariables: experimentalFragmentVariables,\n      allowLegacyFragmentVariables: experimentalFragmentVariables\n    });\n    if (!parsed || parsed.kind !== 'Document') {\n      throw new Error('Not a valid GraphQL document.');\n    }\n    docCache.set(cacheKey, stripLoc(processFragments(parsed)));\n  }\n  return docCache.get(cacheKey);\n}\nexport function gql(literals) {\n  var args = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    args[_i - 1] = arguments[_i];\n  }\n  if (typeof literals === 'string') {\n    literals = [literals];\n  }\n  var result = literals[0];\n  args.forEach(function (arg, i) {\n    if (arg && arg.kind === 'Document') {\n      result += arg.loc.source.body;\n    } else {\n      result += arg;\n    }\n    result += literals[i + 1];\n  });\n  return parseDocument(result);\n}\nexport function resetCaches() {\n  docCache.clear();\n  fragmentSourceMap.clear();\n}\nexport function disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\nexport function enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\nexport function disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\nvar extras = {\n  gql: gql,\n  resetCaches: resetCaches,\n  disableFragmentWarnings: disableFragmentWarnings,\n  enableExperimentalFragmentVariables: enableExperimentalFragmentVariables,\n  disableExperimentalFragmentVariables: disableExperimentalFragmentVariables\n};\n(function (gql_1) {\n  gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;\n})(gql || (gql = {}));\ngql[\"default\"] = gql;\nexport default gql;","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign } from \"tslib\";\nimport { parse } from 'graphql';\nvar docCache = new Map();\nvar fragmentSourceMap = new Map();\nvar printFragmentWarnings = true;\nvar experimentalFragmentVariables = false;\nfunction normalize(string) {\n    return string.replace(/[\\s,]+/g, ' ').trim();\n}\nfunction cacheKeyFromLoc(loc) {\n    return normalize(loc.source.body.substring(loc.start, loc.end));\n}\nfunction processFragments(ast) {\n    var seenKeys = new Set();\n    var definitions = [];\n    ast.definitions.forEach(function (fragmentDefinition) {\n        if (fragmentDefinition.kind === 'FragmentDefinition') {\n            var fragmentName = fragmentDefinition.name.value;\n            var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n            var sourceKeySet = fragmentSourceMap.get(fragmentName);\n            if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n                if (printFragmentWarnings) {\n                    console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n                        + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n                        + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n                }\n            }\n            else if (!sourceKeySet) {\n                fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);\n            }\n            sourceKeySet.add(sourceKey);\n            if (!seenKeys.has(sourceKey)) {\n                seenKeys.add(sourceKey);\n                definitions.push(fragmentDefinition);\n            }\n        }\n        else {\n            definitions.push(fragmentDefinition);\n        }\n    });\n    return __assign(__assign({}, ast), { definitions: definitions });\n}\nfunction stripLoc(doc) {\n    var workSet = new Set(doc.definitions);\n    workSet.forEach(function (node) {\n        if (node.loc)\n            delete node.loc;\n        Object.keys(node).forEach(function (key) {\n            var value = node[key];\n            if (value && typeof value === 'object') {\n                workSet.add(value);\n            }\n        });\n    });\n    var loc = doc.loc;\n    if (loc) {\n        delete loc.startToken;\n        delete loc.endToken;\n    }\n    return doc;\n}\nfunction parseDocument(source) {\n    var cacheKey = normalize(source);\n    if (!docCache.has(cacheKey)) {\n        var parsed = parse(source, {\n            experimentalFragmentVariables: experimentalFragmentVariables,\n            allowLegacyFragmentVariables: experimentalFragmentVariables\n        });\n        if (!parsed || parsed.kind !== 'Document') {\n            throw new Error('Not a valid GraphQL document.');\n        }\n        docCache.set(cacheKey, stripLoc(processFragments(parsed)));\n    }\n    return docCache.get(cacheKey);\n}\nexport function gql(literals) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    if (typeof literals === 'string') {\n        literals = [literals];\n    }\n    var result = literals[0];\n    args.forEach(function (arg, i) {\n        if (arg && arg.kind === 'Document') {\n            result += arg.loc.source.body;\n        }\n        else {\n            result += arg;\n        }\n        result += literals[i + 1];\n    });\n    return parseDocument(result);\n}\nexport function resetCaches() {\n    docCache.clear();\n    fragmentSourceMap.clear();\n}\nexport function disableFragmentWarnings() {\n    printFragmentWarnings = false;\n}\nexport function enableExperimentalFragmentVariables() {\n    experimentalFragmentVariables = true;\n}\nexport function disableExperimentalFragmentVariables() {\n    experimentalFragmentVariables = false;\n}\nvar extras = {\n    gql: gql,\n    resetCaches: resetCaches,\n    disableFragmentWarnings: disableFragmentWarnings,\n    enableExperimentalFragmentVariables: enableExperimentalFragmentVariables,\n    disableExperimentalFragmentVariables: disableExperimentalFragmentVariables\n};\n(function (gql_1) {\n    gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;\n})(gql || (gql = {}));\ngql[\"default\"] = gql;\nexport default gql;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}